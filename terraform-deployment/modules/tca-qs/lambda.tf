# # TODO - Add S3 event trigger for tca_invoke_step_function lambda function
# # Adding S3 bucket as trigger to my lambda and giving the permissions
# # resource "aws_s3_bucket_notification" "tca_input_bucket_events" {
# #   bucket = aws_s3_bucket.tca_input_bucket.id
# #   # lambda_function {
# #   #   lambda_function_arn = aws_lambda_function.tca_invoke_step_function.arn
# #   #   events              = ["s3:ObjectCreated:*", ]
# #   #   # filter_prefix       = "AWSLogs/"
# #   #   # filter_suffix       = ".mp3"


# #   # }
# #   # Send all S3 events for this bucket to EventBridge
# #   eventbridge = true

# # }
# # resource "aws_lambda_permission" "tca_invoke_step_function" {
# #   statement_id  = "AllowS3Invoke"
# #   action        = "lambda:InvokeFunction"
# #   function_name = aws_lambda_function.tca_invoke_step_function.function_name
# #   principal     = "s3.amazonaws.com"
# #   source_arn    = "arn:aws:s3:::${aws_s3_bucket.tca_input_bucket.id}"
# # }




# # TODO - Write this Lambda Function
# # 1. Lambda function to start the Step Function / Data Pipeline
# # Will be triggered by S3 upload event
# resource "aws_lambda_function" "tca_invoke_step_function" {
#   function_name = "tca_invoke_step_function"
#   handler       = "tca_invoke_step_function.lambda_handler"
#   runtime       = "python3.9"
#   # TODO - Reference file generated by archive_file data source
#   filename = "${path.module}/lambda-functions/zip/tca_invoke_step_function.zip"
#   # Necessary to ensure lambda functions are updated if code is modified
#   source_code_hash = data.archive_file.tca_invoke_step_function_zip.output_base64sha256
#   # TODO - Make conditional where full access role will be used
#   # If var.create_full_access_roles is true, use that full_access arn. If not, use the restricted access_arn.
#   # role = var.create_full_access_roles ? aws_iam_role.tca_lambda_invoke_step_functions_state_machine_full_access[0].arn : aws_iam_role.tca_lambda_invoke_sfn_state_machine_restricted_access[0].arn
#   role = aws_iam_role.tca_lambda_invoke_sfn_state_machine_restricted_access[0].arn

#   # depends_on = [
#   #   aws_iam_role.tca_lambda_step_functions_full_access[0],
#   #   aws_iam_role.tca_lambda_step_functions_restricted_access[0],
#   # ]
#   timeout = 300
#   environment {
#     variables = {
#       # Store the SSM Parameter Store key (name of dynamodb table) in Lambda Environmental Variable
#       key_tca_output_bucket_name = aws_ssm_parameter.tca_output_bucket_name.id
#     }
#   }

#   tags = merge(
#     {
#       "AppName" = var.app_name
#     },
#     var.tags,
#   )

# }

# # TODO - Write this Lambda Function
# # 2. - Lambda function to start the transcribe call analytics job
# # Will be invoked by the Step Function
# resource "aws_lambda_function" "tca_start_call_analytics_job" {
#   function_name = "tca_start_call_analytics_job"
#   handler       = "tca_start_call_analytics_job.lambda_handler"
#   runtime       = "python3.9"
#   filename      = "${path.module}/lambda-functions/zip/tca_start_call_analytics_job.zip"
#   # Necessary to ensure lambda functions are updated if code is modified
#   source_code_hash = data.archive_file.tca_start_call_analytics_job_zip.output_base64sha256
#   # role             = var.create_full_access_roles ? aws_iam_role.tca_lambda_transcribe_full_access[0].arn : aws_iam_role.tca_lambda_transcribe_restricted_access[0].arn
#   role    = aws_iam_role.tca_lambda_transcribe_restricted_access[0].arn
#   timeout = 300
#   environment {
#     variables = {
#       # Store the SSM Parameter Store key (name of dynamodb table) in Lambda Environmental Variable
#       key_tca_input_bucket_name = aws_ssm_parameter.tca_input_bucket_name.id
#     }
#   }

#   tags = merge(
#     {
#       "AppName" = var.app_name
#     },
#     var.tags,
#   )
# }

# # TODO - Write this Lambda Function
# # 3. - Lambda function to copy json files from s3 output bucket to web app storage bucket
# # Will be invoked by the Step Function
# resource "aws_lambda_function" "tca_json_s3_to_s3_cp" {
#   function_name = "tca_json_s3_to_s3_cp"
#   handler       = "tca_json_s3_to_s3_cp.lambda_handler"
#   runtime       = "python3.9"
#   filename      = "${path.module}/lambda-functions/zip/tca_json_s3_to_s3_cp.zip"
#   # Necessary to ensure lambda functions are updated if code is modified
#   source_code_hash = data.archive_file.tca_json_s3_to_s3_cp_zip.output_base64sha256
#   # role             = var.create_full_access_roles ? aws_iam_role.tca_lambda_s3_full_access[0].arn : aws_iam_role.tca_lambda_s3_restricted_access[0].arn
#   role    = aws_iam_role.tca_lambda_s3_restricted_access[0].arn
#   timeout = 300
#   environment {
#     variables = {
#       # Store the SSM Parameter Store key (name of dynamodb table) in Lambda Environmental Variable
#       key_tca_output_bucket_name      = aws_ssm_parameter.tca_output_bucket_name.id
#       key_tca_app_storage_bucket_name = aws_ssm_parameter.tca_app_storage_bucket_name.id
#     }
#   }

#   tags = merge(
#     {
#       "AppName" = var.app_name
#     },
#     var.tags,
#   )
# }
# # 4. - Lambda function to write call metadata to DynamoDB
# # Will be invoked by the Step Function
# resource "aws_lambda_function" "tca_s3_to_dynamodb" {
#   function_name = "tca_s3_to_dynamodb"
#   handler       = "tca_s3_to_dynamodb.lambda_handler"
#   runtime       = "python3.9"
#   filename      = "${path.module}/lambda-functions/zip/tca_s3_to_dynamodb.zip"
#   # Necessary to ensure lambda functions are updated if code is modified
#   source_code_hash = data.archive_file.tca_s3_to_dynamodb_zip.output_base64sha256
#   # role             = var.create_full_access_roles ? aws_iam_role.tca_lambda_s3_to_dynamodb_full_access[0].arn : aws_iam_role.tca_lambda_s3_to_dynamodb_restricted_access[0].arn
#   role    = aws_iam_role.tca_lambda_s3_to_dynamodb_restricted_access[0].arn
#   timeout = 300
#   environment {
#     variables = {
#       # Store the SSM Parameter Store key (name of dynamodb table) in Lambda Environmental Variable
#       key_tca_dynamodb_output_table_name = aws_ssm_parameter.tca_dynamodb_output_table_name.id
#     }
#   }

#   tags = merge(
#     {
#       "AppName" = var.app_name
#     },
#     var.tags,
#   )
# }
